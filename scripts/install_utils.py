"""
APIC Installation Utilities Module.
Provides comprehensive utilities for automated installation, configuration,
database setup, and system health checks.
"""

import os
import sys
import re
import shutil
import subprocess
import importlib.util
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from urllib.parse import urlparse
import logging

logger = logging.getLogger(__name__)


# ============================================================================
# Installation Configuration
# ============================================================================

@dataclass
class InstallConfig:
    """Configuration management for APIC installation."""

    project_root: str = None
    venv_dir: str = None
    uploads_dir: str = None
    reports_dir: str = None
    logs_dir: str = None
    min_python_version: tuple = (3, 11)

    def __post_init__(self):
        """Initialize paths after dataclass creation."""
        if self.project_root is None:
            self.project_root = str(Path(__file__).parent.parent.absolute())

        root = Path(self.project_root)

        if self.venv_dir is None:
            self.venv_dir = str(root / ".venv")
        if self.uploads_dir is None:
            self.uploads_dir = str(root / "uploads")
        if self.reports_dir is None:
            self.reports_dir = str(root / "reports")
        if self.logs_dir is None:
            self.logs_dir = str(root / "logs")

    def validate_python_version(self) -> bool:
        """
        Validate that the current Python version meets requirements.

        Returns:
            bool: True if Python version is sufficient.
        """
        current = sys.version_info[:2]
        return current >= self.min_python_version

    def get_all_paths(self) -> Dict[str, str]:
        """Get all configured paths."""
        return {
            "project_root": self.project_root,
            "venv_dir": self.venv_dir,
            "uploads_dir": self.uploads_dir,
            "reports_dir": self.reports_dir,
            "logs_dir": self.logs_dir,
        }


# ============================================================================
# Environment Management
# ============================================================================

class EnvManager:
    """Manages environment file creation and validation."""

    # Required environment variables (must be set for production)
    REQUIRED_VARS = [
        "DATABASE_URL",
    ]

    # Optional but recommended variables
    OPTIONAL_VARS = [
        "OPENAI_API_KEY",
        "ANTHROPIC_API_KEY",
        "PINECONE_API_KEY",
        "PINECONE_ENVIRONMENT",
        "DEFAULT_LLM_PROVIDER",
    ]

    DEFAULT_ENV_CONTENT = """# APIC Environment Configuration
# Auto-generated by installer - Please configure before running

# Application Settings
APP_NAME=APIC
DEBUG=false
ENVIRONMENT=development

# LLM Configuration
DEFAULT_LLM_PROVIDER=openai

# OpenAI Configuration
OPENAI_API_KEY=your-openai-api-key-here
OPENAI_MODEL=gpt-4o

# Anthropic Configuration (alternative)
ANTHROPIC_API_KEY=your-anthropic-api-key-here
ANTHROPIC_MODEL=claude-3-5-sonnet-20241022

# LLM Settings
LLM_TEMPERATURE=0.7
LLM_MAX_TOKENS=4096

# Pinecone Vector Database
PINECONE_API_KEY=your-pinecone-api-key-here
PINECONE_ENVIRONMENT=us-east-1
PINECONE_INDEX_NAME=apic-knowledge

# PostgreSQL Database
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/apic

# File Upload Settings
UPLOAD_DIR=./uploads
MAX_FILE_SIZE_MB=50

# Report Generation
REPORTS_DIR=./reports

# API Configuration
API_HOST=0.0.0.0
API_PORT=8000

# Streamlit Configuration
STREAMLIT_PORT=8501
"""

    def __init__(self, project_root: Optional[str] = None):
        """
        Initialize EnvManager.

        Args:
            project_root: Root directory of the project.
        """
        if project_root is None:
            self.project_root = Path(__file__).parent.parent
        else:
            self.project_root = Path(project_root)

        self.env_path = self.project_root / ".env"
        self.example_path = self.project_root / ".env.example"

    def create_env_file(self, overwrite: bool = False) -> bool:
        """
        Create .env file from .env.example or default template.

        Args:
            overwrite: Whether to overwrite existing .env file.

        Returns:
            bool: True if file was created, False if skipped.
        """
        if self.env_path.exists() and not overwrite:
            logger.info(f".env file already exists at {self.env_path}")
            return False

        # Try to copy from .env.example
        if self.example_path.exists():
            shutil.copy(self.example_path, self.env_path)
            logger.info(f"Created .env from .env.example")
            return True

        # Create from default template
        self.env_path.write_text(self.DEFAULT_ENV_CONTENT)
        logger.info(f"Created .env from default template")
        return True

    def validate_env(self) -> Dict[str, Any]:
        """
        Validate environment variables.

        Returns:
            dict: Validation results with missing and optional_missing keys.
        """
        result = {
            "missing": [],
            "optional_missing": [],
            "valid": True,
        }

        # Load current env vars from file and environment
        env_vars = self._load_env_vars()

        # Check required variables
        for var in self.REQUIRED_VARS:
            if var not in env_vars or not env_vars[var]:
                result["missing"].append(var)
                result["valid"] = False

        # Check optional variables
        for var in self.OPTIONAL_VARS:
            if var not in env_vars or not env_vars[var] or "your-" in str(env_vars.get(var, "")):
                result["optional_missing"].append(var)

        return result

    def _load_env_vars(self) -> Dict[str, str]:
        """Load environment variables from .env file and environment."""
        env_vars = dict(os.environ)

        if self.env_path.exists():
            content = self.env_path.read_text()
            for line in content.splitlines():
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, _, value = line.partition("=")
                    env_vars[key.strip()] = value.strip()

        return env_vars


# ============================================================================
# Directory Management
# ============================================================================

class DirectoryManager:
    """Manages directory creation and permissions for APIC."""

    REQUIRED_DIRS = [
        "uploads",
        "reports",
        "logs",
    ]

    def __init__(self, project_root: Optional[str] = None):
        """
        Initialize DirectoryManager.

        Args:
            project_root: Root directory of the project.
        """
        if project_root is None:
            self.project_root = Path(__file__).parent.parent
        else:
            self.project_root = Path(project_root)

    def create_all_directories(self) -> Dict[str, bool]:
        """
        Create all required directories.

        Returns:
            dict: Mapping of directory names to creation status.
        """
        results = {}

        for dir_name in self.REQUIRED_DIRS:
            dir_path = self.project_root / dir_name
            try:
                dir_path.mkdir(parents=True, exist_ok=True)
                # Set permissions (rwxr-xr-x)
                dir_path.chmod(0o755)
                results[dir_name] = True
                logger.info(f"Created directory: {dir_path}")
            except Exception as e:
                logger.error(f"Failed to create directory {dir_name}: {e}")
                results[dir_name] = False

        return results

    def verify_directories(self) -> Dict[str, Dict[str, bool]]:
        """
        Verify all required directories exist and have correct permissions.

        Returns:
            dict: Verification results for each directory.
        """
        results = {}

        for dir_name in self.REQUIRED_DIRS:
            dir_path = self.project_root / dir_name
            results[dir_name] = {
                "exists": dir_path.exists(),
                "readable": os.access(dir_path, os.R_OK) if dir_path.exists() else False,
                "writable": os.access(dir_path, os.W_OK) if dir_path.exists() else False,
            }

        return results


# ============================================================================
# Database Management
# ============================================================================

class DatabaseManager:
    """Manages database initialization and migrations."""

    def __init__(self, database_url: Optional[str] = None):
        """
        Initialize DatabaseManager.

        Args:
            database_url: PostgreSQL connection URL.
        """
        self.database_url = database_url or os.getenv(
            "DATABASE_URL",
            "postgresql://postgres:postgres@localhost:5432/apic"
        )

    def parse_connection_url(self) -> Dict[str, str]:
        """
        Parse the database connection URL.

        Returns:
            dict: Parsed connection components.
        """
        parsed = urlparse(self.database_url)

        return {
            "user": parsed.username or "postgres",
            "password": parsed.password or "postgres",
            "host": parsed.hostname or "localhost",
            "port": str(parsed.port or 5432),
            "database": parsed.path.lstrip("/") or "apic",
        }

    def validate_connection_url(self) -> bool:
        """
        Validate the database connection URL format.

        Returns:
            bool: True if URL is valid.
        """
        if not self.database_url:
            return False

        try:
            parsed = urlparse(self.database_url)
            return (
                parsed.scheme in ("postgresql", "postgres") and
                parsed.hostname is not None
            )
        except Exception:
            return False

    async def check_connection(self) -> Dict[str, Any]:
        """
        Check database connectivity.

        Returns:
            dict: Connection status with connected and error keys.
        """
        result = {"connected": False, "error": None}

        try:
            import asyncpg
            conn = await asyncpg.connect(self.database_url)
            await conn.execute("SELECT 1")
            await conn.close()
            result["connected"] = True
        except Exception as e:
            result["error"] = str(e)

        return result

    def generate_init_sql(self) -> str:
        """
        Generate database initialization SQL.

        Returns:
            str: SQL statements for database initialization.
        """
        return """
-- APIC Database Initialization Script
-- Auto-generated by installer

-- Create database if not exists (run as superuser)
-- CREATE DATABASE apic;

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create projects table
CREATE TABLE IF NOT EXISTS projects (
    id VARCHAR(36) PRIMARY KEY DEFAULT uuid_generate_v4()::text,
    client_name VARCHAR(255) NOT NULL,
    project_name VARCHAR(255) NOT NULL,
    description TEXT,
    target_departments JSONB DEFAULT '[]'::jsonb,
    status VARCHAR(50) DEFAULT 'created',
    vector_namespace VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create project_states table
CREATE TABLE IF NOT EXISTS project_states (
    id VARCHAR(36) PRIMARY KEY DEFAULT uuid_generate_v4()::text,
    project_id VARCHAR(36) UNIQUE NOT NULL,
    thread_id VARCHAR(36) UNIQUE NOT NULL,
    state_data JSONB NOT NULL,
    current_node VARCHAR(50) DEFAULT 'start',
    is_suspended BOOLEAN DEFAULT FALSE,
    suspension_reason VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create documents table
CREATE TABLE IF NOT EXISTS documents (
    id VARCHAR(36) PRIMARY KEY DEFAULT uuid_generate_v4()::text,
    project_id VARCHAR(36) NOT NULL,
    filename VARCHAR(255) NOT NULL,
    file_type VARCHAR(50) NOT NULL,
    file_size VARCHAR(50) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    chunk_count VARCHAR(50) DEFAULT '0',
    processed BOOLEAN DEFAULT FALSE,
    content_summary TEXT,
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_projects_status ON projects(status);
CREATE INDEX IF NOT EXISTS idx_project_states_project_id ON project_states(project_id);
CREATE INDEX IF NOT EXISTS idx_project_states_is_suspended ON project_states(is_suspended);
CREATE INDEX IF NOT EXISTS idx_documents_project_id ON documents(project_id);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply trigger to tables
DROP TRIGGER IF EXISTS update_projects_updated_at ON projects;
CREATE TRIGGER update_projects_updated_at
    BEFORE UPDATE ON projects
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_project_states_updated_at ON project_states;
CREATE TRIGGER update_project_states_updated_at
    BEFORE UPDATE ON project_states
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
"""


# ============================================================================
# Dependency Checker
# ============================================================================

class DependencyChecker:
    """Validates Python packages and system dependencies."""

    def __init__(self):
        """Initialize DependencyChecker."""
        pass

    def check_package(self, package_name: str) -> Dict[str, Any]:
        """
        Check if a Python package is installed.

        Args:
            package_name: Name of the package to check.

        Returns:
            dict: Package status with installed and version keys.
        """
        result = {"installed": False, "version": None}
        module_name = package_name.replace("-", "_")

        # Primary method: try direct import
        try:
            __import__(module_name)
            result["installed"] = True
            # Try to get version
            try:
                import importlib.metadata
                result["version"] = importlib.metadata.version(package_name)
            except Exception:
                result["version"] = "unknown"
            return result
        except ImportError:
            pass

        # Secondary method: use find_spec
        try:
            spec = importlib.util.find_spec(module_name)
            if spec is not None:
                result["installed"] = True
                result["version"] = "unknown"
        except Exception:
            pass

        return result

    def check_system_dependency(self, command: str) -> Dict[str, Any]:
        """
        Check if a system command is available.

        Args:
            command: Command name to check.

        Returns:
            dict: Availability status with available and path keys.
        """
        result = {"available": False, "path": None}

        path = shutil.which(command)
        if path:
            result["available"] = True
            result["path"] = path

        return result

    def parse_requirements(self, requirements_path: str) -> Dict[str, str]:
        """
        Parse a requirements.txt file.

        Args:
            requirements_path: Path to requirements.txt.

        Returns:
            dict: Mapping of package names to version constraints.
        """
        packages = {}

        try:
            with open(requirements_path, "r") as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith("#") and not line.startswith("-"):
                        # Handle extras like package[extra]>=version
                        match = re.match(r"^([a-zA-Z0-9_-]+)(?:\[[^\]]+\])?(.*)$", line)
                        if match:
                            name = match.group(1)
                            version = match.group(2) if match.group(2) else ""
                            packages[name] = version
        except FileNotFoundError:
            logger.warning(f"Requirements file not found: {requirements_path}")

        return packages

    def check_all_requirements(self, requirements_path: str) -> Dict[str, Dict[str, Any]]:
        """
        Check all packages in a requirements file.

        Args:
            requirements_path: Path to requirements.txt.

        Returns:
            dict: Status of each package.
        """
        packages = self.parse_requirements(requirements_path)
        results = {}

        for package, version in packages.items():
            results[package] = self.check_package(package)

        return results


# ============================================================================
# Health Checker
# ============================================================================

class HealthChecker:
    """Performs system health checks for APIC installation."""

    def __init__(self, project_root: Optional[str] = None):
        """
        Initialize HealthChecker.

        Args:
            project_root: Root directory of the project.
        """
        if project_root is None:
            self.project_root = Path(__file__).parent.parent
        else:
            self.project_root = Path(project_root)

        self.config = InstallConfig(project_root=str(self.project_root))
        self.env_manager = EnvManager(project_root=str(self.project_root))
        self.dir_manager = DirectoryManager(project_root=str(self.project_root))

    def run_all_checks(self) -> Dict[str, Any]:
        """
        Run all health checks.

        Returns:
            dict: Complete health check results.
        """
        results = {
            "python_version": self._check_python_version(),
            "directories": self._check_directories(),
            "environment": self._check_environment(),
            "dependencies": self._check_core_dependencies(),
            "overall_status": "healthy",
        }

        # Determine overall status
        issues = []

        if not results["python_version"]["valid"]:
            issues.append("Python version")

        if not all(d["exists"] for d in results["directories"].values()):
            issues.append("Missing directories")

        if results["environment"]["missing"]:
            issues.append("Missing required env vars")

        if issues:
            results["overall_status"] = "unhealthy" if len(issues) > 1 else "degraded"
            results["issues"] = issues

        return results

    def _check_python_version(self) -> Dict[str, Any]:
        """Check Python version."""
        return {
            "valid": self.config.validate_python_version(),
            "current": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
            "minimum": f"{self.config.min_python_version[0]}.{self.config.min_python_version[1]}",
        }

    def _check_directories(self) -> Dict[str, Dict[str, bool]]:
        """Check required directories."""
        return self.dir_manager.verify_directories()

    def _check_environment(self) -> Dict[str, Any]:
        """Check environment configuration."""
        return self.env_manager.validate_env()

    def _check_core_dependencies(self) -> Dict[str, bool]:
        """Check core Python dependencies."""
        checker = DependencyChecker()
        core_packages = ["fastapi", "sqlalchemy", "pydantic"]

        results = {}
        for pkg in core_packages:
            results[pkg] = checker.check_package(pkg)["installed"]

        return results


# ============================================================================
# Main Installer
# ============================================================================

class Installer:
    """Main installer orchestrator for APIC."""

    def __init__(self, project_root: Optional[str] = None):
        """
        Initialize Installer.

        Args:
            project_root: Root directory of the project.
        """
        if project_root is None:
            self.project_root = Path(__file__).parent.parent
        else:
            self.project_root = Path(project_root)

        self.config = InstallConfig(project_root=str(self.project_root))
        self.env_manager = EnvManager(project_root=str(self.project_root))
        self.dir_manager = DirectoryManager(project_root=str(self.project_root))
        self.health_checker = HealthChecker(project_root=str(self.project_root))

    def check_prerequisites(self) -> Dict[str, Any]:
        """
        Check installation prerequisites.

        Returns:
            dict: Prerequisites check results.
        """
        result = {
            "python": {
                "met": self.config.validate_python_version(),
                "version": f"{sys.version_info.major}.{sys.version_info.minor}",
            },
            "pip": {
                "met": shutil.which("pip") is not None or shutil.which("pip3") is not None,
            },
            "all_met": True,
        }

        result["all_met"] = result["python"]["met"] and result["pip"]["met"]
        return result

    def run_quick_setup(self) -> Dict[str, Any]:
        """
        Run quick setup for development.

        Returns:
            dict: Setup results.
        """
        results = {
            "directories": self.dir_manager.create_all_directories(),
            "env_file": self.env_manager.create_env_file(overwrite=False),
        }

        return results

    def run_full_install(self) -> Dict[str, Any]:
        """
        Run complete installation process.

        Returns:
            dict: Installation results.
        """
        results = {
            "prerequisites": self.check_prerequisites(),
            "directories": None,
            "environment": None,
            "health_check": None,
            "success": False,
        }

        if not results["prerequisites"]["all_met"]:
            logger.error("Prerequisites not met")
            return results

        # Create directories
        results["directories"] = self.dir_manager.create_all_directories()

        # Setup environment
        results["environment"] = self.env_manager.create_env_file()

        # Run health check
        results["health_check"] = self.health_checker.run_all_checks()

        results["success"] = results["health_check"]["overall_status"] in ["healthy", "degraded"]

        return results

    def verify_installation(self) -> Dict[str, Any]:
        """
        Verify the installation is complete and working.

        Returns:
            dict: Verification results.
        """
        return self.health_checker.run_all_checks()


# ============================================================================
# Requirements Analyzer
# ============================================================================

class RequirementsAnalyzer:
    """Analyzes and categorizes Python package requirements."""

    # Core packages required for basic functionality
    CORE_PACKAGES = {
        "fastapi",
        "uvicorn",
        "sqlalchemy",
        "asyncpg",
        "pydantic",
        "pydantic-settings",
        "python-dotenv",
        "httpx",
    }

    # Development-only packages
    DEV_PACKAGES = {
        "pytest",
        "pytest-asyncio",
        "pytest-cov",
        "mypy",
    }

    # Optional feature packages
    OPTIONAL_PACKAGES = {
        "weasyprint",  # PDF generation alternative
    }

    def __init__(self, project_root: Optional[str] = None):
        """
        Initialize RequirementsAnalyzer.

        Args:
            project_root: Root directory of the project.
        """
        if project_root is None:
            self.project_root = Path(__file__).parent.parent
        else:
            self.project_root = Path(project_root)

        self.requirements_path = self.project_root / "requirements.txt"
        self.dep_checker = DependencyChecker()

    def analyze(self) -> Dict[str, Any]:
        """
        Analyze project requirements.

        Returns:
            dict: Analysis results with required, development, optional keys.
        """
        if not self.requirements_path.exists():
            return {
                "required": [],
                "development": [],
                "optional": [],
                "error": "requirements.txt not found",
            }

        packages = self.dep_checker.parse_requirements(str(self.requirements_path))

        result = {
            "required": [],
            "development": [],
            "optional": [],
            "total": len(packages),
        }

        for pkg in packages:
            pkg_lower = pkg.lower()
            if pkg_lower in self.DEV_PACKAGES or any(d in pkg_lower for d in ["test", "lint", "mypy"]):
                result["development"].append(pkg)
            elif pkg_lower in self.OPTIONAL_PACKAGES:
                result["optional"].append(pkg)
            else:
                result["required"].append(pkg)

        return result

    def categorize_packages(self) -> Dict[str, List[str]]:
        """
        Categorize packages into groups.

        Returns:
            dict: Categorized packages.
        """
        analysis = self.analyze()

        return {
            "core": analysis.get("required", []),
            "development": analysis.get("development", []),
            "optional": analysis.get("optional", []),
        }

    def generate_split_requirements(self) -> Dict[str, str]:
        """
        Generate split requirements files content.

        Returns:
            dict: Content for each requirements file.
        """
        categories = self.categorize_packages()
        packages = self.dep_checker.parse_requirements(str(self.requirements_path))

        files = {
            "requirements.txt": "",
            "requirements-dev.txt": "",
            "requirements-optional.txt": "",
        }

        for pkg in categories["core"]:
            version = packages.get(pkg, "")
            files["requirements.txt"] += f"{pkg}{version}\n"

        for pkg in categories["development"]:
            version = packages.get(pkg, "")
            files["requirements-dev.txt"] += f"{pkg}{version}\n"

        for pkg in categories["optional"]:
            version = packages.get(pkg, "")
            files["requirements-optional.txt"] += f"{pkg}{version}\n"

        return files
